<style>
    #rssView {
        margin: 20px;
        height: 100%;
    }
    
    #rssConentView {
        width: 100%;
        height: 100%;
    }
    
    .alignRight {
        float: right;
    }
    
    .bold {
        font-weight: bold;
    }
</style>

<div id="rssView">
    <div id="rssButtonBar" style="overflow: hidden; height: 30px;">
        <button id="newSubscriptionButton" onclick="qBittorrent.Rss.addRSSFeed()">QBT_TR(New subscription)QBT_TR[CONTEXT=RssReaderWidget]</button>
        <button id="markReadButton" onclick="qBittorrent.Rss">QBT_TR(Mark items read)QBT_TR[CONTEXT=RssReaderWidget]</button>
        <button id="updateAllButton" onclick="qBittorrent.Rss.refreshAllFeeds()">QBT_TR(Update all)QBT_TR[CONTEXT=RssReaderWidget]</button>
            
        <button id="rssDownloaderButton" class="alignRight" onclick="qBittorrent.Rss">QBT_TR(RSS Downloader...)QBT_TR[CONTEXT=RssReaderWidget]</button>
    </div>
    <table id="rssConentView">
        <tbody id="rssTableBody">
            <tr id="rssTableRow">
                <td id="rssFeedsRow">
                    <table id="rssFeedsView">
                        <thead>
                            <td>RSS feeds</td>
                        </thead>
                        <tbody id="rssFeedsViewBody"></tbody>
                    </table>
                </td>
                <td>
                    <table id="rssTorrentView">
                        <thead>
                            <td>Torrents</td>
                        </thead>
                        <tbody id="rssTorrentViewBody"> </tbody>
                    </table>
                </td>
                <td>
                    <div id="rssDetailsView">
                    </div>    
                </td>
            </tr>
        </tbody>
    </table>
</div>

<ul id="rssFeedMenu" class="contextMenu">
    <li><a href="#Update"><img src="images/qbt-theme/view-refresh.svg" alt="QBT_TR(Update)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Update)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#MarkRead"><img src="images/qbt-theme/mail-mark-read.svg" alt="QBT_TR(Mark items read)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Mark items read)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li class="separator"><a href="#Rename"><img src="images/qbt-theme/edit-rename.svg" alt="QBT_TR(Rename...)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Rename...)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#Delete"><img src="images/qbt-theme/edit-delete.svg" alt="QBT_TR(Delete)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Delete)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li class="separator"><a href="#CopyFeedURL" id="CopyFeedURL"><img src="images/qbt-theme/edit-copy.svg" alt="QBT_TR(Copy feed URL)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Copy feed URL)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
</ul>

<ul id="rssArticleMenu" class="contextMenu">
    <li><a href="#Download"><img src="images/qbt-theme/download.svg" alt="QBT_TR(Download torrent)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Download torrent)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#OpenNews"><img src="images/qbt-theme/application-x-mswinurl.svg" alt="QBT_TR(Open news URL)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Open news URL)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
</ul>

<script>
    'use strict';

    if (window.qBittorrent === undefined) {
        window.qBittorrent = {};
    }

    window.qBittorrent.Rss = (function() {
        const exports = function() {
            return {
                init: init,
                addRSSFeed: addRSSFeed,
                showRssFeed: showRssFeed,
                showUnreadRssFeed: showUnreadRssFeed,
                showDetails: showDetails,
                updateRssFeedList: updateRssFeedList,
                refreshFeed: refreshFeed,
                refreshAllFeeds: refreshAllFeeds
            };
        };

        let feedData;
        let feedPathMap;
        let rssFeedContextMenu;
        let rssArticleContextMenu;

        const init = function() {
            rssFeedContextMenu = new window.qBittorrent.ContextMenu.RssFeedContextMenu({
                targets: '.rssFeedElement',
                menu: 'rssFeedMenu',
                actions: {
                    Update: function(el) {refreshFeed(el.getAttribute("data-uid"))},
                    MarkRead: function() {console.log("Not implemented");},
                    Rename: function(el) {moveItem(el.getAttribute("data-path"));},
                    Delete: function(el) {removeItem(el.getAttribute("data-path"));}/*,
                    Copy: function(el) {console.log(el.getAttribute("data-url"));}*/
                },
                offsets: {
                    x: -15,
                    y: -53
                }
            });
            rssArticleContextMenu = new window.qBittorrent.ContextMenu.RssArticleContextMenu({
                targets: '.rssArticleElement',
                menu: 'rssArticleMenu',
                actions: {
                    Download: function(el) {
                        showDownloadPage([feedData[el.getAttribute("feed-uid")]
                            .filter(e => e.id = el.getAttribute("data-id"))[0].torrentURL]);
                        },
                    OpenNews: function(el) {
                        window.open(feedData[el.getAttribute("feed-uid")]
                            .filter(e => e.id = el.getAttribute("data-id"))[0].link);
                    }
                },
                offsets: {
                    x: -15,
                    y: -53
                }
            });


            updateRssFeedList();
        };

        new ClipboardJS('#CopyFeedURL', {
            text: function(trigger) {
                console.log(trigger)
                return "Faultier";
            }
        });

        
        const addRSSFeed = function() {
            const url = new URI('api/v2/rss/addFeed');
            
            var feedURL = prompt('Please type a RSS feed URL', 'http://');

            if (feedURL != null) {
                new Request({
                    url: url,
                    noCache: true,
                    method: 'post',
                    data: {
                        url: feedURL,
                        path: ""
                    },
                    onFailure: function(response) {
                        if (response.status == 409) {
                            alert(response.responseText);
                        }
                    },
                    onSuccess: function(response) {
                        updateRssFeedList();
                    }
                }).send();
            }
        };
        
        const showRssFeed = function(feedUid) {
            $('rssTorrentViewBody').empty();
            feedData[feedUid].sort((e1, e2) => new Date(e2.date) - new Date(e1.date))
                .each(torrentEntry => {
                $('rssTorrentViewBody').append((() => {
                    let rssTorrentRow = document.createElement('tr');
                    rssTorrentRow.innerText = torrentEntry.title;
                    rssTorrentRow.setAttribute("feed-uid", feedUid);
                    rssTorrentRow.setAttribute("data-id", torrentEntry.id);
                    rssTorrentRow.addClass("rssArticleElement");
                    rssArticleContextMenu.addTarget(rssTorrentRow);
                    if (!torrentEntry.isRead){
                        rssTorrentRow.addClass("bold");
                    }
                    rssTorrentRow.onclick = function() {
                        qBittorrent.Rss.showDetails(feedUid, torrentEntry.id);
                    }
                    return rssTorrentRow;
                })());
            });
        }

        const showUnreadRssFeed = function() {
            $('rssTorrentViewBody').empty();
            let unreadFeed = [];
            for(let feedEntry in feedData) {
                unreadFeed.append(feedData[feedEntry].filter(e => !e.isRead)
                    .map(f => {f.feedUid = feedEntry; return f;}));
            }
            unreadFeed.sort((e1, e2) => new Date(e2.date) - new Date(e1.date));

            unreadFeed.each(torrentEntry =>  {
                $('rssTorrentViewBody').append((() => {
                    let rssTorrentRow = document.createElement('tr');
                    rssTorrentRow.innerText = torrentEntry.title;
                    rssTorrentRow.setAttribute("feed-uid", torrentEntry.feedUid);
                    rssTorrentRow.setAttribute("data-id", torrentEntry.id);
                    rssTorrentRow.addClass("rssArticleElement");
                    rssArticleContextMenu.addTarget(rssTorrentRow);
                    rssTorrentRow.addClass("bold");
                    rssTorrentRow.onclick = function() {
                        qBittorrent.Rss.showDetails(torrentEntry.feedUid, torrentEntry.id);
                    }
                    return rssTorrentRow;
                })());
            });
        };

        const showDetails = function(feedUid, articleID) {
            $('rssDetailsView').empty();
            let article = feedData[feedUid].filter(article => article.id == articleID)[0];
            if (article) {
                $('rssDetailsView').append((() => {
                    let torrentName = document.createElement('p');
                    torrentName.innerText = "Name: " + article.title;
                    torrentName.setAttribute("id", "rssTorrentDetailsName");
                    return torrentName;
                })());
                $('rssDetailsView').append((() => {
                    let torrentDate = document.createElement('p');
                    torrentDate.innerText = "Date: " + article.date;
                    torrentDate.setAttribute("id", "rssTorrentDetailsDate");
                    return torrentDate;
                })());
                //Strip script before interpreting html
                let torrentDescription = document.createRange().createContextualFragment(
                        "<div id=\"rssTorrentDetailsDescription\">" + article.description.stripScripts() + "</div>");
                $('rssDetailsView').append(torrentDescription);
            }
        };
        
        const updateRssFeedList = function() {
            const url = new URI('api/v2/rss/items');
            new Request.JSON({
                url: url,
                noCache: true,
                method: 'post',
                data: {
                    withData: true
                },
                onSuccess: function(response) {
                    $('rssFeedsViewBody').empty();
                    feedData = {};
                    feedPathMap = new Map();
                    console.log(response);
                    for(let feedEntry in response) {
                        feedPathMap.set(response[feedEntry].uid, feedEntry);
                        $('rssFeedsViewBody').append((() => {
                            let rssFeedRow = document.createElement('tr');
                            let numberOfUnread = response[feedEntry].articles.map(art => !art.isRead).filter(v => v).length;
                            rssFeedRow.innerText = feedEntry + ' (' + numberOfUnread + ')';
                            rssFeedRow.setAttribute("data-uid", response[feedEntry].uid);
                            rssFeedRow.setAttribute("data-url", response[feedEntry].url);
                            rssFeedRow.setAttribute("data-path", feedEntry);
                            rssFeedRow.addClass("rssFeedElement");
                            rssFeedContextMenu.addTarget(rssFeedRow);
                            if (response[feedEntry].hasError) {
                            }
                            if (response[feedEntry].isLoading) {
                            }						
                            feedData[response[feedEntry].uid] = response[feedEntry].articles;
                            rssFeedRow.onclick = function() {
                                qBittorrent.Rss.showRssFeed(response[feedEntry].uid);
                            }
                            return rssFeedRow;
                        })());
                    }
                    //unread entry
                    $('rssFeedsViewBody').prepend((() => {
                            let unreadRow = document.createElement('tr');
                            let numberOfUnread = 0;
                            for(let feedEntry in feedData) {
                                numberOfUnread += feedData[feedEntry].map(art => !art.isRead).filter(v => v).length;
                            }
                            unreadRow.innerText = "Unread" + ' (' + numberOfUnread + ')';		
                            unreadRow.onclick = function() {
                                qBittorrent.Rss.showUnreadRssFeed("unread");
                            }
                            return unreadRow;
                        })());
                    
                }
            }).send();
        };

        const refreshFeed = function(feedUid, callback = () => {}) {
            console.log(feedUid);
            console.log(feedPathMap.get(feedUid));
            const url = new URI('api/v2/rss/refreshItem');
            new Request({
                url: url,
                noCache: true,
                method: 'post',
                data: {
                    itemPath: feedPathMap.get(feedUid)
                },
                onSuccess: function(response) {
                    callback(0);
                },
                onFailure: function(response) {
                    callback(1);
                }
            }).send();
        };

        const refreshAllFeeds = function() {
            var promises = [];
            for(let feedEntry in feedData) {
                promises.push(new Promise(function(resolve, reject) {
                    refreshFeed(feedEntry, r => {
                        if (r == 0)
                            resolve();
                        else
                            reject();
                    });
                }));
            }
            Promise.all(promises).then(async function() {
                //needs to be replaced by auto reload
                await new Promise((e) => {setTimeout(e, 1000);});
                updateRssFeedList();
            });
        };

        const moveItem = function(oldPath) {
            var newPath = prompt('Please choose a new name for this RSS feed', oldPath);

            if (newPath != null) {
                const url = new URI('api/v2/rss/moveItem');
                new Request({
                    url: url,
                    noCache: true,
                    method: 'post',
                    data: {
                        itemPath: oldPath,
                        destPath: newPath
                    },
                    onSuccess: function(response) {
                        updateRssFeedList()
                    },
                    onFailure: function(response) {
                        if (response.status == 409) {
                            alert(response.responseText);
                        }
                    }
                }).send();
            }
        };

        const removeItem = function(path) {
            if (confirm('Are you sure you want to delete the selected RSS feeds?')) {
                const url = new URI('api/v2/rss/removeItem');
                new Request({
                    url: url,
                    noCache: true,
                    method: 'post',
                    data: {
                        path: path
                    },
                    onSuccess: function(response) {
                        updateRssFeedList()
                    },
                    onFailure: function(response) {
                        if (response.status == 409) {
                            alert(response.responseText);
                        }
                    }
                }).send();
            }
        };

        return exports();
    })();



</script>