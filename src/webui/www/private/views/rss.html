<style>
    #rssView {
        padding: 20px;
    }

    #rssConentView {
        width: 100%;
    }

    #rssFeedFixedHeaderDiv .dynamicTableHeader,  #rssArticleFixedHeaderDiv .dynamicTableHeader{
        cursor: default;
    }

    #rssTableBody {
        vertical-align: top;
    }

    .alignRight {
        float: right;
    }

    .unreadArticle {
        color: blue;
    }
    
    #rssFetchingDisabled {
        color: red;
        font-style: italic;
        margin-bottom: 10px;
    }
</style>

<div id="rssView">
    <div id="rssFetchingDisabled" class="invisible">QBT_TR(Fetching of RSS feeds is disabled now! You can enable it in application settings.)QBT_TR[CONTEXT=RssReaderWidget]</div>
    <div id="rssButtonBar" style="overflow: hidden; height: 30px;">
        <button id="newSubscriptionButton" onclick="qBittorrent.Rss.addRSSFeed()">QBT_TR(New subscription)QBT_TR[CONTEXT=RssReaderWidget]</button>
        <button id="markReadButton" onclick="qBittorrent.Rss.markSelectedAsRead()">QBT_TR(Mark items read)QBT_TR[CONTEXT=RssReaderWidget]</button>
        <button id="updateAllButton" onclick="qBittorrent.Rss.refreshAllFeeds()">QBT_TR(Update all)QBT_TR[CONTEXT=RssReaderWidget]</button>
        
        <button id="rssDownloaderButton" class="alignRight" onclick="qBittorrent.Rss.openRssDownloader()">QBT_TR(RSS Downloader...)QBT_TR[CONTEXT=RssReaderWidget]</button>
    </div>
    <table id="rssConentView">
        <tbody id="rssTableBody">
            <tr id="rssTableRow">
                <td id="rssFeedsRow" style="width:33%">
                    <div id="rssFeedFixedHeaderDiv" class="dynamicTableFixedHeaderDiv">
                        <table class="dynamicTable unselectable" style="position:relative; width:100%">
                            <thead style="width:100%">
                                <tr class="dynamicTableHeader" style="width:100%"></tr>
                            </thead>
                        </table>
                    </div>
                    <div id="rssFeedTableDiv" class="dynamicTableDiv">
                        <table class="dynamicTable unselectable" style="width:100%">
                            <thead style="width:100%">
                                <tr class="dynamicTableHeader" style="width:100%"></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </td>
                <td id="rssArticleRow" style="width:33%">
                    <div id="rssArticleFixedHeaderDiv" class="dynamicTableFixedHeaderDiv">
                        <table class="dynamicTable unselectable" style="position:relative; width:100%">
                            <thead style="width:100%">
                                <tr class="dynamicTableHeader" style="width:100%"></tr>
                            </thead>
                        </table>
                    </div>
                    <div id="rssArticleTableDiv" class="dynamicTableDiv">
                        <table class="dynamicTable unselectable" style="width:100%">
                            <thead style="width:100%">
                                <tr class="dynamicTableHeader" style="width:100%"></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </td>
                <td id="rssDetailsRow">
                    <div id="rssDetailsView">
                    </div>    
                </td>
            </tr>
        </tbody>
    </table>
</div>

<ul id="rssFeedMenu" class="contextMenu">
    <li><a href="#update"><img src="images/qbt-theme/view-refresh.svg" alt="QBT_TR(Update)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Update)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#markRead"><img src="images/qbt-theme/mail-mark-read.svg" alt="QBT_TR(Mark items read)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Mark items read)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li class="separator"><a href="#rename"><img src="images/qbt-theme/edit-rename.svg" alt="QBT_TR(Rename...)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Rename...)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#delete"><img src="images/qbt-theme/edit-delete.svg" alt="QBT_TR(Delete)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Delete)QBT_TR[CONTEXT=RssReaderWidget]</a></li>

    <li class="separator"><a href="#newSubscription"><img src="images/qbt-theme/document-new.svg" alt="QBT_TR(New subscription...)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(New subscription...)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#newFolder"><img src="images/qbt-theme/folder-new.svg" alt="QBT_TR(New folder...)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(New folder...)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li class="separator"><a href="#updateAll"><img src="images/qbt-theme/view-refresh.svg" alt="QBT_TR(Update all feeds)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Update all feeds)QBT_TR[CONTEXT=RssReaderWidget]</a></li>

    <li class="separator"><a href="#copyFeedURL" id="CopyFeedURL"><img src="images/qbt-theme/edit-copy.svg" alt="QBT_TR(Copy feed URL)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Copy feed URL)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
</ul>

<ul id="rssArticleMenu" class="contextMenu">
    <li><a href="#Download"><img src="images/qbt-theme/download.svg" alt="QBT_TR(Download torrent)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Download torrent)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
    <li><a href="#OpenNews"><img src="images/qbt-theme/application-x-mswinurl.svg" alt="QBT_TR(Open news URL)QBT_TR[CONTEXT=RssReaderWidget]"/> QBT_TR(Open news URL)QBT_TR[CONTEXT=RssReaderWidget]</a></li>
</ul>

<script>
    'use strict';

    if (window.qBittorrent === undefined) {
        window.qBittorrent = {};
    }
    let rssFeedTable = new window.qBittorrent.DynamicTable.RssFeedTable();
    let rssArticleTable = new window.qBittorrent.DynamicTable.RssArticleTable();

    window.qBittorrent.Rss = (function() {
        const exports = function() {
            return {
                init: init,
                addRSSFeed: addRSSFeed,
                showRssFeed: showRssFeed,
                showUnreadRssFeed: showUnreadRssFeed,
                showDetails: showDetails,
                updateRssFeedList: updateRssFeedList,
                refreshFeed: refreshFeed,
                refreshAllFeeds: refreshAllFeeds,
                moveItem: moveItem,
                removeItem: removeItem,
                markItemAsRead: markItemAsRead,
                markArticleAsRead: markArticleAsRead,
                markSelectedAsRead: markSelectedAsRead,
                openRssDownloader: openRssDownloader
            };
        };

        let feedData;
        let pathToFeedIdMap;
        let rssFeedContextMenu;
        let rssArticleContextMenu;

        const init = function() {
            new Request.JSON({
                url: 'api/v2/app/preferences',
                method: 'get',
                noCache: true,
                onFailure: function() {
                    alert("Could not contact qBittorrent");
                },
                onSuccess: function(pref) {
                    if (!pref.rss_processing_enabled)
                        $('rssFetchingDisabled').removeClass('invisible');
                }
            }).send();
            
            rssFeedContextMenu = new window.qBittorrent.ContextMenu.RssFeedContextMenu({
                targets: '.rssFeedContextMenuTarget',
                menu: 'rssFeedMenu',
                actions: {
                    update: (el) => {
                        if (rssFeedTable.selectedRows.contains(0)) {
                            refreshAllFeeds();
                        }
                        else {
                            rssFeedTable.selectedRows.each(row => {
                                refreshFeed(rssFeedTable.rows[row].full_data.dataUid);
                            });
                        }
                    },
                    markRead: markSelectedAsRead,
                    rename: (el) => {
                            moveItem(rssFeedTable.rows[rssFeedTable.selectedRows[0]].full_data.dataPath);
                    },
                    delete: (el) => {
                        removeItem(rssFeedTable.selectedRows
                            .filter(e => e != 0)
                            .map(sRow => rssFeedTable.rows[sRow].full_data.dataPath));
                    },
                    newSubscription: addRSSFeed,
                    newFolder: (el) => {console.log("[not implemented] folders are not implemnted");},
                },
                offsets: {
                    x: -16,
                    y: -57
                }
            });
            
            rssFeedContextMenu.addTarget($('rssFeedTableDiv'));
            //deselect feed when clicking on empty part of table
            $('rssFeedTableDiv').addEventListener("click", function(e) {
                rssFeedTable.deselectAll();
                rssFeedTable.deselectRow();
            });
            $('rssFeedTableDiv').addEventListener("contextmenu", function(e) {
                if (e.toElement.nodeName == "DIV") {
                    rssFeedTable.deselectAll();
                    rssFeedTable.deselectRow();
                    rssFeedContextMenu.updateMenuItems();
                }
            });

            new ClipboardJS('#CopyFeedURL', {
                text: () => {
                    let joined = "";
                    rssFeedTable.selectedRows
                        .filter(row => rssFeedTable.rows[row].full_data.dataUid != "")
                        .each(row => joined += rssFeedTable.rows[row].full_data.dataUrl + '\n');
                    return joined.slice(0,-1);
                }
            });
            rssFeedTable.setup('rssFeedTableDiv', 'rssFeedFixedHeaderDiv', rssFeedContextMenu);


            rssArticleContextMenu = new window.qBittorrent.ContextMenu.RssArticleContextMenu({
                targets: '.rssArticleElement',
                menu: 'rssArticleMenu',
                actions: {
                    Download: function(el) {
                        let dlString = "";
                        rssArticleTable.selectedRows.each(row => {
                            dlString += rssArticleTable.rows[row].full_data.torrentURL + "\n";
                        });
                        showDownloadPage([dlString]);
                        },
                    OpenNews: function(el) {
                        rssArticleTable.selectedRows.each(row => {
                            window.open(rssArticleTable.rows[row].full_data.link);
                        });
                    }
                },
                offsets: {
                    x: -16,
                    y: -57
                }
            });
            rssArticleTable.setup('rssArticleTableDiv', 'rssArticleFixedHeaderDiv', rssArticleContextMenu);
            updateRssFeedList();
        };

        const addRSSFeed = function() {
            new MochaUI.Window({
                id: 'newFeed',
                title: "QBT_TR(Please type a RSS feed URL)QBT_TR[CONTEXT=RssReaderWidget]",
                loadMethod: 'iframe',
                contentURL: 'newfeed.html',
                scrollbars: false,
                resizable: false,
                maximizable: false,
                paddingVertical: 0,
                paddingHorizontal: 0,
                width: 350,
                height: 100
            });
        };
        
        const showRssFeed = function(feedUid) {
            rssArticleTable.clear();
            let rowCount = 0;
            feedData[feedUid].sort((e1, e2) => new Date(e2.date) - new Date(e1.date))
                .each(torrentEntry => {
                rssArticleTable.updateRowData({
	                rowId: rowCount++,
                    name: torrentEntry.title,
                    link: torrentEntry.link,
                    feedUid: feedUid,
                    dataId: torrentEntry.id,
                    torrentURL: torrentEntry.torrentURL,
                    isRead: torrentEntry.isRead
                });
            });
            $('rssDetailsView').empty();
            rssArticleTable.updateTable(false);
        };

        const showUnreadRssFeed = function() {
            rssArticleTable.clear();
            let rowCount = 0;
            let unreadFeed = [];
            for (let feedEntry in feedData) {
                unreadFeed.append(feedData[feedEntry].filter(e => !e.isRead)
                    .map(f => {
                        f.feedUid = feedEntry;
                        return f;}
                        ));
            }
            
            unreadFeed.sort((e1, e2) => new Date(e2.date) - new Date(e1.date))
                .each(torrentEntry =>  {
                rssArticleTable.updateRowData({
	                rowId: rowCount++,
                    name: torrentEntry.title,
                    link: torrentEntry.link,
                    feedUid: torrentEntry.feedUid,
                    dataId: torrentEntry.id,
                    isRead: false
                });
            });
            $('rssDetailsView').empty();
            rssArticleTable.updateTable(false);
        };

        const showDetails = function(feedUid, articleID) {
            markArticleAsRead(pathToFeedIdMap.get(feedUid), articleID);
            $('rssDetailsView').empty();
            let article = feedData[feedUid].filter(article => article.id == articleID)[0];
            if (article) {
                $('rssDetailsView').append((() => {
                    let torrentName = document.createElement('p');
                    torrentName.innerText = "Name: " + article.title;
                    torrentName.setAttribute("id", "rssTorrentDetailsName");
                    return torrentName;
                })());
                $('rssDetailsView').append((() => {
                    let torrentDate = document.createElement('p');
                    torrentDate.innerText = "Date: " + article.date;
                    torrentDate.setAttribute("id", "rssTorrentDetailsDate");
                    return torrentDate;
                })());
                //Strip script before interpreting html
                let torrentDescription = document.createRange().createContextualFragment(
                        "<div id=\"rssTorrentDetailsDescription\">" + article.description.stripScripts() + "</div>");
                
                $('rssDetailsView').append(torrentDescription);
            }
        };
        
        const updateRssFeedList = function() {
            new Request.JSON({
                url: 'api/v2/rss/items',
                noCache: true,
                method: 'post',
                data: {
                    withData: true
                },
                onSuccess: function(response) {
                    rssFeedTable.clear();
                    feedData = {};
                    pathToFeedIdMap = new Map();
                    //flatten folder structure
                    let flattenedResp = [];
                    function recFlatten(current, name = '', depth = 0, fullName = '') {
                        for (let child in current) {
                            let currentFullname = fullName ? fullName + "\\" + child : child;
                            if (current[child].uid !== undefined) {
                                current[child].name = child;
                                current[child].isFolder = false;
                                current[child].depth = depth;
                                current[child].fullName = currentFullname;
                                flattenedResp.push(current[child]);
                            }
                            else {
                                flattenedResp.push({
                                    name: child,
                                    isFolder: true,
                                    depth: depth,
                                    fullName: currentFullname
                                });
                                recFlatten(current[child], child, depth + 1, currentFullname);
                            }
                        }
                    }
                    recFlatten(response);

                    //Unread entry at top
                    rssFeedTable.updateRowData({
                        rowId: 0,
                        name: 'Unread',
                        unread: 0,
                        status: "unread",
                        indentaion: 0,
                        dataUid: "",
                        dataUrl: "",
                        dataPath: ""
                    });

                    let rowCount = 1;
                    for (let dataEntry of flattenedResp) {
                        if (dataEntry.isFolder) {
                            rssFeedTable.updateRowData({
                                rowId: rowCount,
                                name: dataEntry.name,
                                unread: 0,
                                status: 'isFolder',
                                indentaion: dataEntry.depth,
                                dataUid: "",
                                dataUrl: "",
                                dataPath: dataEntry.fullName
                            });
                        }
                        else {
                            let status = "default";
                            if (dataEntry.hasError)
                                status = "hasError";
                            if (dataEntry.isLoading)
                                status = "isLoading";

                            rssFeedTable.updateRowData({
                                rowId: rowCount,
                                name: dataEntry.name,
                                unread: 0,
                                status: status,
                                indentaion: dataEntry.depth,
                                dataUid: dataEntry.uid,
                                dataUrl: dataEntry.url,
                                dataPath: dataEntry.fullName
                            });

                            //calculate number of unread
                            let numberOfUnread = dataEntry.articles.map(art => !art.isRead).filter(v => v).length;
                            //find all items that contain this rss feed and add unread count
                            rssFeedTable.rows.filter(row => dataEntry.fullName.slice(0, row.full_data.dataPath.length) == row.full_data.dataPath)
                                .each(row => {
                                    rssFeedTable.updateRowData({
                                        rowId: row.rowId,
                                        unread: row.full_data.unread + numberOfUnread
                                    });
                            });

                            pathToFeedIdMap.set(dataEntry.uid, dataEntry.fullName);
                            feedData[dataEntry.uid] = dataEntry.articles;
                        }
                        ++rowCount;
                    }
                    rssFeedTable.updateTable(false);
                    rssFeedTable.updateIcons();
                }
            }).send();
        };

        const refreshFeed = function(feedUid) {
            //set icon to loading
            for (let rowId in rssFeedTable.rows) {
                let row = rssFeedTable.rows[rowId];
                if (row.full_data.dataUid == feedUid) {
                    row.full_data.status = "isLoading";
                    break;
                }
            }
            rssFeedTable.updateIcons();

            new Request({
                url: 'api/v2/rss/refreshItem',
                noCache: true,
                method: 'post',
                data: {
                    itemPath: pathToFeedIdMap.get(feedUid)
                },
                onFailure: function(response) {
                    if (response.status == 409)
                        alert(response.responseText);
                }
            }).send();
        };

        const refreshAllFeeds = function() {
            for (let feedEntry in feedData)
                refreshFeed(feedEntry);
        };

        const moveItem = function(oldPath) {
            new MochaUI.Window({
                id: 'renamePage',
                title: "QBT_TR(Please choose a new name for this RSS feed)QBT_TR[CONTEXT=RssReaderWidget]",
                loadMethod: 'iframe',
                contentURL: 'rename_feed.html?oldPath=' + encodeURIComponent(oldPath),
                scrollbars: false,
                resizable: false,
                maximizable: false,
                paddingVertical: 0,
                paddingHorizontal: 0,
                width: 350,
                height: 100
            });
        };

        const removeItem = function(paths) {
            new MochaUI.Window({
                id: 'confirmFeedDeletionPage',
                title: "QBT_TR(Deletion confirmation)QBT_TR[CONTEXT=RssReaderWidget]",
                loadMethod: 'iframe',
                contentURL: 'confirmfeeddeletion.html?paths=' + encodeURIComponent(paths.join("|")),
                scrollbars: false,
                resizable: false,
                maximizable: false,
                padding: 10,
                width: 350,
                height: 80
            });
        };

        const markItemAsRead = function(path) {
            //feed data mark as read
            for (let feedID in feedData)
                if (pathToFeedIdMap.get(feedID) == path)
                    feedData[feedID].each(el => el.isRead = true);

            //mark rows as read
            rssArticleTable.rows.each(el => el.full_data.isRead = true);

            //find row
            let rowId, prevUnreadCount;
            for (let rowID in rssArticleTable.rows) {
                let row = rssFeedTable.rows[rowID];
                if (row.full_data.dataPath == path) {
                    rowId = row.full_data.rowId;
                    prevUnreadCount = row.full_data.unread;
                    break;
                }
            }

            //find all items that contain this feed and subtract previous unread count
            rssFeedTable.rows.filter(row => path.slice(0, row.full_data.dataPath.length) == row.full_data.dataPath)
                 .each(row => {
                    rssFeedTable.updateRowData({
                        rowId: row.rowId,
                        unread: row.full_data.unread - prevUnreadCount
                    });
            });

            rssArticleTable.updateTable(false);
            rssFeedTable.updateTable(true);

            //send request
            new Request({
                url: 'api/v2/rss/markItemAsRead',
                noCache: true,
                method: 'post',
                data: {
                    path: path
                },
                onFailure: function(response) {
                    if (response.status == 409)
                        alert(response.responseText);
                }
            }).send();
        };

        const markArticleAsRead = function(path, id) {
            //find row
            let rowId, name, uid, unread;
            for (let rowID in rssArticleTable.rows) {
                let row = rssFeedTable.rows[rowID];
                if (row.full_data.dataPath == path) {
                    rowId = row.full_data.rowId;
                    name = row.full_data.dataPath;
                    uid = row.full_data.dataUid;
                    unread = row.full_data.unread;
                    break;
                }
            }
            //update feed data
            let prevReadState = true;
            feedData[uid].each(article => {
                if (article.id == id) {
                    prevReadState = article.isRead;
                    article.isRead = true;
                }
            });

            if (!prevReadState) {
                //find all items that contain this feed and subtract 1
                rssFeedTable.rows.filter(row => path.slice(0, row.full_data.dataPath.length) == row.full_data.dataPath)
                    .each(row => {
                        console.log("row " + row.rowId + " unread count " + row.full_data.unread);
                        rssFeedTable.updateRowData({
                            rowId: row.rowId,
                            unread: row.full_data.unread - 1
                        });
                });
                rssFeedTable.updateTable(true);

                new Request({
                    url: 'api/v2/rss/markArticleAsRead',
                    noCache: true,
                    method: 'post',
                    data: {
                        itemPath: path,
                        articleId: id
                    },
                    onFailure: function(response) {
                       if (response.status == 409)
                            alert(response.responseText);
                    }
                }).send();
            }
        };
        
        const markSelectedAsRead = function() {
            if (rssFeedTable.selectedRows.contains(0)) {
                rssFeedTable.rows.filter(row => rssFeedTable.rows[row].full_data.dataUid != "")
                    .each(row => markItemAsRead(row.full_data.dataPath));
            }
            else {
                rssFeedTable.selectedRows.each(row => {
                    markItemAsRead(rssFeedTable.rows[row].full_data.dataPath);
                });
            }
        };

        const openRssDownloader = function() {

        };

        return exports();
    })();



</script>